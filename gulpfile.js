"use strict";

// modules
var gulp = require('gulp'),
	del = require('del'),
	exec = require('child_process').exec,
	browserSync = require('browser-sync').create(),
	watch = require('gulp-watch'),
	autoprefixer = require('gulp-autoprefixer'),
	sass = require('gulp-ruby-sass'),
	sourcemaps = require('gulp-sourcemaps'),
	csso = require('gulp-csso'),
	csscomb = require('gulp-csscomb'),
	imagemin = require('gulp-imagemin'),
	runSequence = require('run-sequence'),
	gutil = require('gulp-util'),
	ftp = require('vinyl-ftp'),
	gulpif = require('gulp-if'),
	args = require('yargs').argv,
	fs = require('fs'),
	isDev = args.env === 'development',
	gitMsg = args.msg === ("Style updates from Pattern Lab ['" + Date() + "']");


// configuration
var config = {
	sourcefiles: "./source",
	compiled: "./public",
	files: {
		colors: {
			src: './source/_data/colors.json',
			dist: './source/sass/_00-settings_colors.scss'
		},
		styles: {
			sass: './source/sass/style.scss',
			dist: './public/css/',
			css: './public/css/style.css',
			pl: './core/styleguide/css/styleguide.scss'
		},
		images: {
			src: './source/images/**/*',
			dist: './public/images/'
		},
		scripts: {
			src: './source/js/**/*',
			dist: './public/js/'
		}
	}
};


// server for compiled P.L. in "public" directory
gulp.task('clean', function(cb) {
	//del([config.compiled], cb);

	del('./public/sass', cb);
});


// compile sass (using Sass Ruby gem)
// includes autoprefix for better browser support
gulp.task('styles:sass', function() {
    return sass(config.files.styles.sass, {
    		sourcemap: (isDev) ? true : false,
	        lineNumber: (isDev) ? true : false
    	})
    	.on('error', function (err) {
      		console.error('Error!', err.message);
   		})
   		.pipe(autoprefixer({
            browsers: ['last 3 versions'],
            cascade: false
        }))
   		.pipe(gulpif(isDev, sourcemaps.write('maps', {
	        includeContent: false,
	        sourceRoot: '.'
	    })))
   		.pipe(gulpif(!isDev, csso()))
   		.pipe(gulpif(!isDev, csscomb()))
    	.pipe(gulp.dest(config.files.styles.dist))
    	.pipe(gulpif(isDev, browserSync.stream()));
});


gulp.task('styles:pl', function() {
    return sass(config.files.styles.pl, {
    		sourcemap: (isDev) ? true : false,
	        lineNumber: (isDev) ? true : false
    	})
    	.on('error', function (err) {
      		console.error('Error!', err.message);
   		})
   		.pipe(autoprefixer({
            browsers: ['last 3 versions'],
            cascade: false
        }))
   		.pipe(gulpif(isDev, sourcemaps.write('maps', {
	        includeContent: false,
	        sourceRoot: '.'
	    })))
   		.pipe(gulpif(!isDev, csso()))
   		.pipe(gulpif(!isDev, csscomb()))
    	.pipe(gulp.dest('./public/styleguide/css/'))
    	.pipe(gulpif(isDev, browserSync.stream()));
});


// grouping of all style task
gulp.task('styles', ['styles:sass'], function() {
	var tasks;

	if (isDev) {
		tasks = [
			'clean',
			'styles:pl'
		];
	} else {
		tasks = [
			'styles:pl'
		];
	}

	// run all tasks related to styling (CSS/Sass/etc)
	runSequence(tasks);
});


// images
gulp.task('images', function () {
	return gulp.src(config.files.images.src)
		// .pipe(gulpif(!isDev, imagemin()))
		.pipe(gulp.dest('./public/images/'));
});


// scripts
gulp.task('scripts', function () {
	return gulp.src(config.files.scripts.src)
		// .pipe(gulpif(!isDev, imagemin()))
		.pipe(gulp.dest('./public/js/'));
});

// pulls JSON data and creates Sass color variables
gulp.task('colors', function() {
	var contents = require(config.files.colors.src),
		intromsg = '////////////////////////////////////////////////////////////////////////\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// !!!! WARNING !!!! \n// THIS FILE (`' + config.files.colors.dist + '`)\n// IS GENERATED BY `' + config.files.colors.src + '` DO NOT EDIT THIS FILE \n// !!!! WARNING !!!!\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n////////////////////////////////////////////////////////////////////////\n\n\n',
		obj = intromsg,
		extendobj;

	fs.readFile(config.files.colors.src, function (err, contents) {
	  if (err) throw err;

		var data = JSON.parse(contents),
			colors = data.colors,
			colorlength = colors.length;

		for (var i = 0; i < colorlength; i++) {
			var color = colors[i],
				children = colors[i].extended,
				childrenlength = (children) ? children.length : 0,
				variablename = "";

			obj += "$" + color.name +
				   ": " + color.value + ";\n";

			if (childrenlength > 0) {
				for (var x = 0; x < childrenlength; x++) {
					obj += '$' + children[x] + ": " + "$" + color.name + ";\n";

					if (x >= (childrenlength - 1)) {
						obj += "\n"
					}
				}
			} else {
				obj += "\n"
			}

			if (i == (colorlength - 1)) {
				obj += "\n\n" + intromsg;
			}
		}

		fs.writeFile(config.files.colors.dist, obj);
	});
});


// build PL
// gulp.task('build:simple', function() {
// 	if (isDev) {
// 		exec('php core/builder.php -p;', function() {
// 				gulp.src(config.sourcefiles).pipe(browserSync.stream());
// 			}
// 		});
// 	} else {
// 		fs.writeFileSync('./public/styleguide/html/styleguide.html', '');

// 		exec('php core/builder.php -g;', function() {
// 				gulp.src(config.sourcefiles).pipe(browserSync.stream());
// 			}
// 		});
// 	}
// });




gulp.task('build', function() {
	fs.writeFileSync('./public/styleguide/html/styleguide.html', '');

	if (isDev) {
		exec('php core/builder.php -g -p;', function() {
			// if (isDev) {
				gulp.src(config.sourcefiles).pipe(browserSync.stream());
			// }
		});
	} else {
		exec('php core/builder.php -g;', function() {
			gulp.src(config.sourcefiles).pipe(browserSync.stream());
		});
	}
});


// run tasks when files are updated
gulp.task('watch', function() {
	gulp.task('colors:watch', ['colors']);
	gulp.watch('./source/_data/colors.json', ['colors:watch']);

	gulp.task('styles:watch', ['styles']);
	gulp.watch('./source/sass/**/*.scss', ['styles:watch']);
	gulp.watch('./core/styleguide/css/styleguide.scss', ['styles:watch']);

	gulp.task('images:watch', ['images']);
	gulp.watch('./source/images/**/*', ['images:watch']);

	gulp.task('scripts:watch', ['scripts']);
	gulp.watch('./source/js/**/*', ['scripts:watch']);

	gulp.task('json:watch', ['build']);
	gulp.watch('./source/**/*.json', ['json:watch']);
	gulp.task('mustache:watch', ['build']);
	gulp.watch('./source/**/*.mustache', ['mustache:watch']);

	gulp.task('font:watch', ['build']);
	gulp.watch(['./source/fonts/**/*'], ['font:watch']);


	// gulp.task('build:watch', ['styles', 'scripts', 'build']);
	// gulp.watch([
	// 			'./source/fonts/**/*'
	// 			], ['build:watch']);
});


// server for compiled P.L. in "public" directory
gulp.task('serve', function() {
	browserSync.init({
		server: {
			baseDir: config.compiled
		}
	});
});


// default build
gulp.task('default', ['clean'], function() {
	// define build tasks
	var tasks = [
		'build',
		'colors',
		'images',
		'styles'
	];

	// add tasks if development
	if (isDev) {
		tasks.push('watch');
	}

	// run build and tasks
	runSequence(tasks, function() {
		// start watcher if "development"
		if (isDev) {
			gulp.start('serve');
		}
	});
});
